function sim = simulateWatercolumn(p, bLogDepth, Diff, nTout)
%
% Load library:
%
if libisloaded("model")
    unloadlibrary("model")
end
loadlibrary('../Cpp/model.so','../Cpp/model.h')
% Constants:
idxN = 1;
idxDOC = 2;
idxB = 3:(2+p.n);
%
% Set parameters in C engine:
%
calllib('model','setParameters', ...
    int32(p.n), ...
    double(p.m), ...
    double(p.rhoCN), ...
    double(p.epsilonL), ...
    double(p.epsilonF), ...
    double(p.ANm), ...
    double(p.ALm), ...
    double(p.AFm), ...
    double(p.Jmax), ...
    double(p.JFmaxm), ...
    double(p.Jresp), ...
    double(p.Jloss_passive_m), ...
    double(p.theta), ...
    double(p.mort), ...
    double(p.mort2), ...
    double(p.mortHTL*p.mortHTLm), ...
    double(p.remin), ...
    double(p.remin2), ...
    double(p.cLeakage));
%
% Set up grid and solution matrix:
%
if (bLogDepth)
    b = (1/p.depth)^((1/(-p.nGrid)));
    a = 1/b;
    x = double( a*b.^(1:(p.nGrid)-1) );
else
    x = linspace(0, p.depth, p.nGrid);
end

u = zeros(2+p.n, p.nGrid, p.tEnd/p.dt+1);
% Initial conditions:
u(idxN,:,1) = p.N0/3;
u(idxDOC,:,1) = p.DOC0;
u(idxB,:,1) = (ones(p.nGrid,1)*p.B0)';
u(idxB, x>50, 1) = 1e-8;
%
% Simulate
tic()
itmp = int32(0);
[tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,itmp,tmp8,u] = calllib('model','simulateWaterColumn', ...
    double(p.L), ...
    double(p.T), ...
    Diff, ...
    double(p.N0), ...
    double(p.tEnd), ...
    double(p.dt), ...
    int32(p.nGrid), ...
    x, ...
    u);
toc()
%
% Extract results:
%
idxT = floor(linspace(1,p.tEnd/p.dt,nTout));
idxX = p.nGrid:-1:1;
sim.u = reshape(u, 2+p.n, p.nGrid, p.tEnd/p.dt+1);

sim.N = squeeze(sim.u(idxN, idxX, idxT));
sim.DOC = squeeze(sim.u(idxDOC, idxX, idxT));
sim.B = sim.u(idxB, idxX, idxT);
%d = calcESD(p.m)
%sim.Bpico = t(colSums(sim.B[d<2,,],1))
%sim.Bnano = t(colSums(sim.B[d>=2 & d<20,,],1))
%sim.Bmicro = t(colSums(sim.B[d>=20,,],1))

sim.t = 0:p.dt:p.tEnd;
sim.t = sim.t(idxT);
sim.x = -x(p.nGrid:-1:1);

sim.p = p;

end
